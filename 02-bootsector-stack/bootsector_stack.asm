;--------------------------------------------------------------------------
;
;    文件名：    bootsector_stack.asm
;    功  能：    通过堆栈的方式输出字符ABC
;    描  述：    1.栈：
;                    栈是一种数据结构,可以用来保存一些寄存器的值. 主要
;                    用在函数调用过程中,C语言中我们了解到,函数调用前会将一
;                    些局部变量入栈,也即保存现场; 执行完调用函数后,局部变
;                    量会出栈,也即恢复现场. 这样可以保证整个程序调用过程中
;                    不会发生错误. 
;                2.栈存储形式：
;                    栈的地址增长方向时自上向下的,符合'先进后出,后进先出'
;                    的规则.注意：16位模式下,栈数据是16位,也即两个字节
;                    例如下图：
;                                  ~ ~ ~        地址 
;                    栈底指针bp-> -------      0x8000
;                                 |  0  |     
;                                 -------        
;                                 |  C  |
;                                 -------      0x7ffe
;                                 |  0  |      
;                                 -------      
;                                 |  B  |
;                                 -------      0x7ffc
;                                 |  0  |   
;                                 -------      
;                                 |  A  |  
;                    栈顶指针sp-> -------      0x7ffa
;                                  ~ ~ ~
;                 3.两种方式访问数据：
;                    (1):使用栈底指针偏移量访问(基址寻址)：mov dx [bp+2n]
;                    (2):使用出栈的方式访问：pop指令 pop bx
;                    注意：方式一访问不会破坏栈结构, 方式二访问后,栈消失,
;                    所以先测试方式一.
;    步  骤：    linux下在终端执行：
;                    nasm -f bin bootsector_stack.asm
;                    qemu bootsector_stack
;    结  果：    屏幕显示ABCABBC
;
;--------------------------------------------------------------------------


mov ah, 0x0e                 ; 设置为tty模式输出字符

mov bp, 0x8000               ; bp为栈底指针,可以用来访问变量.这里设置栈底
                             ; 指针指向内存地址为0x8000
mov sp, bp                   ; 初始化栈顶指针,也即栈底指针和栈顶指针重合

push 'C'                     ; 将字母C以两个字节的方式入栈,高字节0低字节C
push 'B'                     ; 将字母B以两个字节的方式入栈,高字节0低字节B
push 'A'                     ; 将字母A以两个字节的方式入栈,高字节0低字节A

                             ; 方式一访问：使用栈底指针偏移量
mov dx, [bp-6]               ; 访问[栈底指针所指向的地址减去6个字节的地址]
                             ; 的内容,也即访问字母A,取出A放到寄存器dx中
                             ; 高字节dh为0,低字节dl为A
mov al, dl                   ; 将dl中的A取出放到al中,省去了寄存器dh中的0
int 0x10                     ; 调用BIOS中断0x10H,将al中的值放到显存中显示

mov dx, [bp-4]               ; 访问字母B
mov al, dl
int 0x10

mov dx, [bp-2]               ; 访问字母C
mov al, dl
int 0x10
                             ; 方式二访问：使用数据出栈的方式
pop bx                       ; 以两个字节方式弹出栈顶的值放到寄存器bx中
                             ; 高字节bh为0,低字节bl为A.同时栈顶指针移位
                             ; 指向下一个数据,执行前后sp的变化
                             ; 由sp->0x7ffa 变成 sp->0x7ffc
mov al, bl                   ; 将bl中的A取出放到al中,省去了寄存器bh中的0
int 0x10                     ; 调用BIOS中断0x10H,将al中的值放到显存中显示

mov al, [0x7ffc]             ; 直接寻址方式访问栈顶数据,也即访问字母B
                             ; 注意这条指令不能乱用,因为该地值处于栈顶
                             ; 所以才可以访问,栈内的数据只有栈顶数据才
                             ; 可以直接寻址.可以把0x7ffc改成0x7ffe来验证
                             ; 结果并不会显示出A,因为字母A在栈内,不属于
                             ; 栈顶数据,执行前后sp不变化且指向0x7ffc
int 0x10


pop bx                       ; 弹出字母B放到bx中,执行前后sp的变化
                             ; 由sp->0x7ffc 变成 sp->0x7ffe
mov al, bl
int 0x10

pop bx                       ; 弹出字母C放到bx中,执行前后sp的变化
                             ; 由sp->0x7ffe 变成 0x8000
mov al, bl
int 0x10

jmp $                        ; 无限循环

times 510-($-$$) db 0        ; 从汇编代码的结束位置到扇区的第510个字节填0
dw 0xaa55                    ; 启动扇区的标志
